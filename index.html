<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Production Dashboard</title>

<link href="style.css" rel="stylesheet"/>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet"/>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

</head>
<body>

<div class="container-fluid">

  <div class="header-section">
    <div class="clocks mb-2">
      <iframe src="https://free.timeanddate.com/clock/ia4vsg4z/n250/tlca/fs72/ftb/pa10/tt1/tm1" frameborder="0"></iframe>
      <iframe src="https://free.timeanddate.com/clock/ia4vsg4z/n250/tlca/fs132/ftb/" frameborder="0"></iframe>
    </div>
    <h1>
        <select id="orderTypeToggle" class="form-select w-auto d-inline-block">
          <option value="medium">Medium Duty</option>
          <option value="light">Light Duty</option>
        </select>
        Production Dashboard
    </h1>
  </div>

  <div class="table-section">
    <div id="output"></div>
  </div>
</div>

<script>
const hiddenColumnIndexes = [2,4,7,8,10];     // columns to hide
// New visible column indexes
const statusColumnIndex = 2;                // color "PAST DUE" or "OKAY"
const partColumnIndex = 3;                  // part number
const checkColumnIndex = 4;                 // remove rows where this column is empty
const xlsxFileUrl = "data/latest.xlsx";

// Manually define widths for each visible column
const columnWidths = {
  0: "12%",
  1: "10%",
  2: "15%",
  3: "25%",
  4: "8%"
};

function buildHtmlTable(rows) {
  if (rows.length === 0) return "<p>No data to display.</p>";

  const colCount = rows[0].length;

  /* ---------- BUILD TABLE HEADER ---------- */
  let thead = "<thead><tr>";
  for (let i = 0; i < colCount; i++) {
    const width = columnWidths[i] ? `style="width:${columnWidths[i]};"` : "";
    thead += `<th ${width}>${rows[0][i]}</th>`;
  }
  thead += "</tr></thead>";

  /* ---------- BUILD TABLE BODY ---------- */
  let tbody = "<tbody>";

  for (let r = 1; r < rows.length; r++) {
    tbody += "<tr>";

    for (let c = 0; c < colCount; c++) {
      let cellValue = rows[r][c] || "";
      let style = "";

      // Apply manual width
      if (columnWidths[c]) {
        style += `width:${columnWidths[c]};`;
      }

      // ===== STATUS COLUMN DATE COLORING =====
      if (c === statusColumnIndex) {
        const parsed = new Date(cellValue);
        if (!isNaN(parsed)) {
          const today = new Date().setHours(0, 0, 0, 0);
          const cellDate = parsed.setHours(0, 0, 0, 0);

          if (cellDate < today) style += "color:red; font-weight:bold;";
          else style += "color:green; font-weight:bold;";
        }
      }

      tbody += `<td style="${style}">${cellValue}</td>`;
    }

    tbody += "</tr>";
  }

  tbody += "</tbody>";

  return `<table>${thead}${tbody}</table>`;
}


// Determine Medium vs Light Duty
function getDutyType(partNumber){
  if (partNumber === undefined || partNumber === null) return "light";
  let str = String(partNumber).trim().toUpperCase();
  if (!str.includes("-")) return "light"; // invalid part#, treat as light
  const first = str.split("-")[0];
  if (first.includes("M") || first.includes("CA") || first.includes("HRNS"))
    return "medium";
  return "light";
}

function filterByDuty(rows, type){
  return rows.filter((row, idx) => {
    if (idx === 0) return true;
    return getDutyType(row[partColumnIndex]) === type;
  });
}

function renderFiltered(){
  const type = document.getElementById("orderTypeToggle").value;
  localStorage.setItem("orderTypeToggle", type);
  document.getElementById("output").innerHTML = buildHtmlTable(filterByDuty(allRows, type));
  addEllipsisTooltips();
}

// Load XLSX
function loadAndRenderTable(){
  fetch(xlsxFileUrl)
    .then(res => {
      if (!res.ok) throw new Error("File not found");
      return res.arrayBuffer();
    })
    .then(data => {
      const workbook = XLSX.read(data, { type: "array" });
      const sheet = workbook.SheetNames[0];
      let rows = XLSX.utils.sheet_to_json(workbook.Sheets[sheet], { header: 1 });

      rows = rows.map(row => row.filter((_, idx) => !hiddenColumnIndexes.includes(idx)));

      rows = rows.filter(row => {
        const v = row[checkColumnIndex];
        return v !== undefined && v !== null && v !== "";
      });

      const colCount = rows[0].length;
      rows = rows.map(r => {
        while (r.length < colCount) r.push("");
        return r;
      });

      allRows = rows;

      const saved = localStorage.getItem("orderTypeToggle");
      if (saved) document.getElementById("orderTypeToggle").value = saved;

      renderFiltered();
    })
    .catch(err => {
      console.error(err);
      document.getElementById("output").innerHTML =
        `<p class="error-message">Error loading table.</p>`;
    });
}

loadAndRenderTable();
document.getElementById("orderTypeToggle").addEventListener("change", renderFiltered);

// Add tooltips to first column
function addEllipsisTooltips() {
  document.querySelectorAll("table tbody tr td:first-child").forEach(td => {
    td.title = td.textContent;  // full original content
  });
}
  
// Auto-refresh daily @ 8 AM
function scheduleDailyRefresh(hour = 8, minute = 0){
  const now = new Date();
  let next = new Date();
  next.setHours(hour, minute, 0, 0);
  if (now > next) next.setDate(next.getDate() + 1);

  setTimeout(() => {
    loadAndRenderTable();
    scheduleDailyRefresh(hour, minute);
  }, next - now);
}
scheduleDailyRefresh();
</script>

</body>
</html>
